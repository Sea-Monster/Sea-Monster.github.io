<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="量">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="量">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="量">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>量</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">量</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/部署Scrapy爬虫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/部署Scrapy爬虫/" itemprop="url">部署Scrapy爬虫</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T11:33:09+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我用Scrapy开发了若干爬虫（若干Spider），但每次运行需要在命令行输入指令运行，假如我需要让若干个Spider同时运行，而且监控它们运行状态，而且再进一步考虑，如果Spider的数目非常多，如何管理？</p>
</blockquote>
<h1 id="安装工具-库"><a href="#安装工具-库" class="headerlink" title="安装工具/库"></a>安装工具/库</h1><h2 id="安装scrapyd"><a href="#安装scrapyd" class="headerlink" title="安装scrapyd"></a>安装scrapyd</h2><h2 id="安装scrapyd-client"><a href="#安装scrapyd-client" class="headerlink" title="安装scrapyd-client"></a>安装scrapyd-client</h2><p>Scrapyd-Client为了方便Scrapy项目的部署，提供如下两个功能：</p>
<ul>
<li>将项目打包成Egg文件</li>
<li>将打包生成的Egg文件通过addversion.json接口部署到Scrapyd上<br>Scrapyd-Client帮我们把部署全部实现了，我们不需关心Egg是怎么生成的，要不需要再去读Egg文件并请求接口上传了，只需执行一个命令即可一键部署。<h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2>这应该算惯例了，把需要用到的库的名字列表放到requirements.txt的文件中，部署的时候，让系统自动下载这些依赖库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在项目的根目录下运行：</span><br><span class="line">$ pip3 freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="部署爬虫"><a href="#部署爬虫" class="headerlink" title="部署爬虫"></a>部署爬虫</h1><h2 id="运行scrapyd"><a href="#运行scrapyd" class="headerlink" title="运行scrapyd"></a>运行scrapyd</h2><p>执行后，默认在本机6800端口启动scrapyd服务，直接用浏览器访问可以看到服务上有哪些Job（爬虫），运行情况如何<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scrapyd</span><br></pre></td></tr></table></figure></p>
<h2 id="发布工程到scrapyd"><a href="#发布工程到scrapyd" class="headerlink" title="发布工程到scrapyd"></a>发布工程到scrapyd</h2><h3 id="修改scapy-cfg文件"><a href="#修改scapy-cfg文件" class="headerlink" title="修改scapy.cfg文件"></a>修改scapy.cfg文件</h3><p>scapy.cfg文件位于工程根目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Automatically created by: scrapy startproject</span><br><span class="line">#</span><br><span class="line"># For more information about the [deploy] section see:</span><br><span class="line"># https://scrapyd.readthedocs.io/en/latest/deploy.html</span><br><span class="line"></span><br><span class="line">[settings]</span><br><span class="line">default = DictSpider.settings</span><br><span class="line"></span><br><span class="line">[deploy]</span><br><span class="line">#url = http://localhost:6800/</span><br><span class="line">project = DictSpider</span><br><span class="line"></span><br><span class="line"># deploy:s1表示把爬虫发布到名为s1的爬虫服务器上。这个名字可以随意起，一般情况用在需要同时发布爬虫到多个目标服务器时，可以通过指定名字的方式发布到指定服务器。</span><br><span class="line">[deploy:s1]</span><br><span class="line"># 这个url就是你的scrapyd服务器的网址</span><br><span class="line">url = http://138.0.0.141:6800/</span><br><span class="line">project = DictSpider</span><br></pre></td></tr></table></figure></p>
<h3 id="发布爬虫"><a href="#发布爬虫" class="headerlink" title="发布爬虫"></a>发布爬虫</h3><p>在工程的根目录下运行，命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scrapyd-deploy &lt;target&gt; -p &lt;project&gt; --version &lt;version&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>target就是前面配置文件里deploy后面的的target名字。如果之前scapy.cfg中没有指定target名字，这里可以不写</li>
<li>project 可以随意定义，跟爬虫的工程名字无关</li>
<li>version自定义版本号，不写的话默认为当前时间戳。</li>
</ul>
<p>注意之前启动的scrapyd服务必须正在运行。运行成功会有类似如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这一条是运行的命令，我们发布一个test1的工程</span><br><span class="line">$ scrapyd-deploy -p test1 </span><br><span class="line">Packing version 1545203675</span><br><span class="line">Deploying to project &quot;test1&quot; in http://localhost:6800/addversion.json</span><br><span class="line">2018-12-19T15:14:39+0800 [twisted.python.log#info] &quot;127.0.0.1&quot; - - [19/Dec/2018:07:14:35 +0000] &quot;POST /addversion.json HTTP/1.1&quot; 200 122 &quot;-&quot; &quot;Python-urllib/3.6&quot;</span><br><span class="line">Server response (200):</span><br><span class="line">&#123;&quot;node_name&quot;: &quot;SeaMonster-MacBook-Pro.local&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;project&quot;: &quot;test1&quot;, &quot;version&quot;: &quot;1545203675&quot;, &quot;spiders&quot;: 12&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>我们可以通过直接访问API的方式调用启动、停止接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 格式：curl http://localhost:6800/schedule.json -d project=default -d spider=somespider</span><br><span class="line">$ curl http://localhost:6800/schedule.json -d project=test1 -d spider=gdggzy_gov</span><br></pre></td></tr></table></figure></p>
<p>如果我们要停止正在运行的爬虫，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:6800/cancel.json -d project=test1 -d job=jobid </span><br><span class="line"># jobid不要带&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="scrapyd的日志乱码问题"><a href="#scrapyd的日志乱码问题" class="headerlink" title="scrapyd的日志乱码问题"></a>scrapyd的日志乱码问题</h4><p>用Chrome浏览器打开scrapyd服务端，可以看到爬虫运行的日志，但是中文内容有可能出现乱码，原因是“chrome 5.5 之后取消编码设置，采用自动识别编码,但是在部分设置不规范不正确的网站，新版浏览器无法准确判断其使用的编码，导致网站显示乱码”。我们可以通过安装Chrome插件解决。插件地址：<br><a href="https://chrome.google.com/webstore/detail/oenllhgkiiljibhfagbfogdbchhdchml" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/oenllhgkiiljibhfagbfogdbchhdchml</a><br>GitHub开源地址：<br><a href="https://github.com/jinliming2/Chrome-Charset" target="_blank" rel="noopener">https://github.com/jinliming2/Chrome-Charset</a></p>
<h1 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h1><p>如果我们要把爬虫部署到多个服务器，或者经常要更换服务器，每次都重新配置环境实在太麻烦了，因此我选择用Docker，只要每个服务器都装上Docker，我只需一次搞好Docker镜像，然后就能随意在多个服务器上使用了。</p>
<h2 id="构建基于Python3的镜像"><a href="#构建基于Python3的镜像" class="headerlink" title="构建基于Python3的镜像"></a>构建基于Python3的镜像</h2><h3 id="Scrapyd对接Docker"><a href="#Scrapyd对接Docker" class="headerlink" title="Scrapyd对接Docker"></a>Scrapyd对接Docker</h3><p>在工程根目录下新建一个scrapyd.conf，即Scrapyd的配置文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[scrapyd]</span><br><span class="line">eggs_dir    = eggs</span><br><span class="line">logs_dir    = logs</span><br><span class="line">items_dir   =</span><br><span class="line">jobs_to_keep = 5</span><br><span class="line">dbs_dir     = dbs</span><br><span class="line">max_proc    = 0</span><br><span class="line"># 这里指CPU单核最多运行4个Scrapy任务</span><br><span class="line">max_proc_per_cpu = 4</span><br><span class="line">finished_to_keep = 100</span><br><span class="line">poll_interval = 5.0</span><br><span class="line"># bind_address = 127.0.0.1 这样只能够从本地访问，因此改为0.0.0.0，允许其他地方公开访问</span><br><span class="line">bind_address = 0.0.0.0</span><br><span class="line">http_port   = 6800</span><br><span class="line">debug       = off</span><br><span class="line">runner      = scrapyd.runner</span><br><span class="line">application = scrapyd.app.application</span><br><span class="line">launcher    = scrapyd.launcher.Launcher</span><br><span class="line">webroot     = scrapyd.website.Root</span><br><span class="line"></span><br><span class="line">[services]</span><br><span class="line">schedule.json     = scrapyd.webservice.Schedule</span><br><span class="line">cancel.json       = scrapyd.webservice.Cancel</span><br><span class="line">addversion.json   = scrapyd.webservice.AddVersion</span><br><span class="line">listprojects.json = scrapyd.webservice.ListProjects</span><br><span class="line">listversions.json = scrapyd.webservice.ListVersions</span><br><span class="line">listspiders.json  = scrapyd.webservice.ListSpiders</span><br><span class="line">delproject.json   = scrapyd.webservice.DeleteProject</span><br><span class="line">delversion.json   = scrapyd.webservice.DeleteVersion</span><br><span class="line">listjobs.json     = scrapyd.webservice.ListJobs</span><br><span class="line">daemonstatus.json = scrapyd.webservice.DaemonStatus</span><br></pre></td></tr></table></figure></p>
<p>基本就是<a href="https://scrapyd.readthedocs.io/en/latest/config.html#example-configuration-file" target="_blank" rel="noopener">https://scrapyd.readthedocs.io/en/latest/config.html#example-configuration-file</a>的内容。</p>
<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>新建一个Dockerfile，文件名字随意，例如mydockerfile，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">COPY ./scrapyd.conf /etc/scrapyd/</span><br><span class="line">EXPOSE 6800</span><br><span class="line">RUN pip3 install -i https://pypi.douban.com/simple/ -r requirements.txt</span><br><span class="line">CMD scrapyd</span><br></pre></td></tr></table></figure></p>
<p>第一行的FROM是指在python:3.6这个镜像上构建，也就是说在构建时就已经有了Python 3.6的环境。<br>第二行的ADD是将本地的代码放置到虚拟容器中。它有两个参数：第一个参数是.，即代表本地当前路径；第二个参数/code代表虚拟容器中的路径，也就是将本地项目所有内容放置到虚拟容器的/code目录下。<br>第三行的WORKDIR是指定工作目录，这里将刚才添加的代码路径设成工作路径，这个路径下的目录结构和当前本地目录结构是相同的，所以在这个目录下可以直接执行库安装命令。<br>第四行的COPY是将当前目录下的scrapyd.conf文件复制到虚拟容器中/etc/scrapyd/目录下，Scrapyd在运行时会默认读取这个配置。<br>第五行的EXPOSE是声明运行时容器提供服务端口，注意这里只是一个声明，运行时不一定会在此端口开启服务。这个声明的作用，一是告诉使用者这个镜像服务的运行端口，以方便配置映射，二是在运行使用随机端口映射时，容器会自动随机映射EXPOSE的端口。<br>第六行的RUN是执行某些命令，一般做一些环节准备工作。由于Docker虚拟容器内只有Python3环境，没有Python库，所以我们运行此命令来在虚拟容器中安装相应的Python库，这样项目部署到Scrapyd中便可以正常运行。<br>第七行的CMD是容器启动命令，容器运行时，此命令会被执行。这里我们直接用scrapyd来启动Scrapyd服务。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>格式如下（不要漏了最后的那一个点）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f dockerfile文件 -t 自定镜像名字:自定镜像标签（默认latest） .</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f mydockerfile -t tisson/scrapyd:latest .</span><br></pre></td></tr></table></figure></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>构建成功后即可运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 6800:6800 tisson/scrapyd:latest</span><br></pre></td></tr></table></figure></p>
<p>然后打开localhost:6800可以看到Scrapyd服务。</p>
<h3 id="【重要】补充说明"><a href="#【重要】补充说明" class="headerlink" title="【重要】补充说明"></a>【重要】补充说明</h3><p>你也许留意到，我们使用Docker后只是启动了Scrapyd服务，实际上爬虫并没有部署上去。因此我们还需要修改一些地方</p>
<h4 id="新建脚本文件"><a href="#新建脚本文件" class="headerlink" title="新建脚本文件"></a>新建脚本文件</h4><p>在工程根目录下新建start.sh文件（文件名可以随意），内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">scrapyd &amp;</span><br><span class="line">scrapyd-deploy -p DictSpider &gt;&gt; scrapy.log</span><br><span class="line">tail -f scrapy.log</span><br></pre></td></tr></table></figure></p>
<p>首先我们启动Scrapyd服务，并让它在后台运行，然后才能部署爬虫。<code>scrapyd-deploy -p DictSpider &gt;&gt; scrapy.log</code>这句就是部署爬虫到Scrapyd服务，其中“DictSpider”是工程名，可任意指定，然后我们把结果输出到scrapy.log文件。留意最后的那句<code>tail -f scrapy.log</code>。其实scrapy.log这个文件没什么内容，我们这句不是为了观察其内容，而是为了让Docker容器一直运行，否则爬虫刚部署上去还没跑，整个Docker容器就停止了：<strong>Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</strong>之前尝试过，后台运行Scrapyd服务，然后部署爬虫，再用fg命令尝试把后台的Scrapyd服务切换到前台，结果死活报no such job，只能用这种办法了。</p>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>修改mydockerfile，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">COPY ./scrapyd.conf /etc/scrapyd/</span><br><span class="line">EXPOSE 6800</span><br><span class="line">RUN pip3 install -i https://pypi.douban.com/simple/ -r requirements.txt</span><br><span class="line">RUN chmod 755 start.sh</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;./start.sh&quot;]</span><br></pre></td></tr></table></figure></p>
<p>在之前docker file的基础上修改了最后两行。 </p>
<h4 id="构建镜像、启动服务"><a href="#构建镜像、启动服务" class="headerlink" title="构建镜像、启动服务"></a>构建镜像、启动服务</h4><p>然后构建镜像的命令依旧是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f mydockerfile -t tisson/scrapyd:latest .</span><br></pre></td></tr></table></figure></p>
<p>启动服务的语句同样不变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 6800:6800 tisson/scrapyd:latest</span><br></pre></td></tr></table></figure></p>
<p>最后是启动爬虫（DictSpider就是执行scrapyd-deploy时指定的名字）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:6800/schedule.json -d project=DictSpider -d spider=gdggzy_gov</span><br></pre></td></tr></table></figure></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>用docker logs看不到爬虫的日志，进去容器内，打开scrapy.log，同样没看到日志，它在哪里呢：<code>logs/project名/Spider名/</code>，以本项目为例，我们设置了容器内的工作目录为/code，工程名为DictSpider，spider名为gdggzy_gov，那么日志路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/code/logs/DictSpider/gdggzy_gov/</span><br></pre></td></tr></table></figure></p>
<h2 id="整合Selenium所需的各种Web-Driver"><a href="#整合Selenium所需的各种Web-Driver" class="headerlink" title="整合Selenium所需的各种Web Driver"></a>整合Selenium所需的各种Web Driver</h2><p>很多时候，直接模拟网络请求并不容易，例如页面上某些内容是AJAX返回的，而这个AJAX请求需要带上n多不知道哪里冒出来的参数。这时我们一般就不想费心去摸索哪些参数怎么来的，直接用Selenium加上各种浏览器驱动，模拟各种点击啊输入啊等操作，剩下的事情，“浏览器”帮我们解决。<br>但是，这种方法在本机上跑没问题，但是如果部署到服务器上跑就难说了，浏览器要用到GUI，但服务器大多数没有GUI。因此，我们还需要在服务器上装一个名叫“xvfb”的东西。<br>这一整套东西自己装还是挺麻烦的，例如安装Chrome的话还需要找对应的chrome-drive包，版本不一致无法使用，还有各种奇怪的坑。幸好，早已有人帮我们把这些东西整合了，我们直接使用这个别人已经整合好的Docker镜像。  </p>
<ul>
<li>chromium-xvfb-py3：在Docker hub上能直接找到，下载即可，不过它的Python版本稍旧，现在是3.5的</li>
<li>thsheep/chromium-xvfb-py3：这个和上边那个类似，而它的Python版本是3.6.3的，我们就选择它了</li>
</ul>
<p>那么，我们就在这个镜像的基础上构建我们的爬虫镜像吧，之前的dockerfile修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM docker.io/thsheep/chromium-xvfb-py3:master</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">COPY ./scrapyd.conf /etc/scrapyd/</span><br><span class="line">EXPOSE 6800</span><br><span class="line">RUN pip3 install -i https://pypi.douban.com/simple/ -r requirements.txt</span><br><span class="line">RUN chmod 755 start.sh</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;./start.sh&quot;]</span><br></pre></td></tr></table></figure></p>
<p>其实就是修改了第一行。<br>真正用的时候还有其他坑，例如：<br><a href="https://segmentfault.com/a/1190000016154179" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016154179</a></p>
<blockquote>
<p>chrome和chromium都不能在root模式下运行，而且也不安全。所以最好是创建一个用户来运行。使用docker的时候，run时候需要加–privileged参数<br>还有：<a href="http://dockone.io/article/2232" target="_blank" rel="noopener">http://dockone.io/article/2232</a><br>在编译运行后，发现在这个Docker容器内单纯的去访问网页没有问题，如果去执行带有键盘的操作时，会报错。经过调查是需要在启动容器时执行Xvfb，申请一块Screen<br>这个等我遇到了再补充。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/CentOS系统添加用户/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/CentOS系统添加用户/" itemprop="url">CentOS系统添加用户</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T11:32:23+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>据说平常使用root用户不够安全，那么还是创建另外的用户吧</p>
</blockquote>
<h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p>首先创建用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adduser 用户名</span><br></pre></td></tr></table></figure></p>
<p>然后分配密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd 用户名</span><br></pre></td></tr></table></figure></p>
<p>按提示连续2次输入密码</p>
<h1 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h1><p>对linux不太熟，只为了完成日常开发，最好是用的账号和root几乎没有区别。首先我们用以下命令切换到root账号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br></pre></td></tr></table></figure></p>
<p>按提示输入root账号的密码，然后修改/etc/sudoers配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ visudo</span><br></pre></td></tr></table></figure></p>
<p>找到以下几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></p>
<p>然后再root那一会下边加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></p>
<p>退出。之后要执行命令，在命令前加上sudo，再输入密码（当前用户的密码），就可以成功执行了，例如，我安装了docker，然后执行docker ps它需要root权限，那么我这样就可成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps</span><br><span class="line">[sudo] password for 用户名:</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">81b7ac1e12d1        mysql:5.7.23        &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 3 hours          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql57</span><br></pre></td></tr></table></figure></p>
<h2 id="免密码"><a href="#免密码" class="headerlink" title="免密码"></a>免密码</h2><p>每次sudo都要输入密码很麻烦，我们把以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名  ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/sudo环境变量-某次使用maven插件docker-maven-plugin制作镜像引发的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/sudo环境变量-某次使用maven插件docker-maven-plugin制作镜像引发的问题/" itemprop="url">sudo环境变量-某次使用maven插件docker-maven-plugin制作镜像引发的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T11:31:34+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一开始都是用root用户操作Docker，后来用了非root用户，产生了各种问题。这次是使用maven插件docker-maven-plugin制作镜像时引起的各种问题</p>
</blockquote>
<p>命令如下，当使用root用户时正常运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package -D maven.test.skip=true docker:build -f pom.xml</span><br></pre></td></tr></table></figure></p>
<p>使用非root用户，却报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: Permission denied</span><br><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: Permission denied</span><br><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: Permission denied</span><br><span class="line">一月 15, 2019 6:12:46 下午 org.apache.http.impl.execchain.RetryExec execute</span><br><span class="line">信息: Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 01:59 min</span><br><span class="line">[INFO] Finished at: 2019-01-15T18:12:46+08:00</span><br><span class="line">[INFO] Final Memory: 64M/1150M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.11:build (default-cli) on project elves: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.io.IOException: Permission denied -&gt; [Help 1]</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</span><br></pre></td></tr></table></figure></p>
<h1 id="操作Docker的权限"><a href="#操作Docker的权限" class="headerlink" title="操作Docker的权限"></a>操作Docker的权限</h1><p>首先想到的是当前用户没有操作Docker的权限，因此在前边加上sudo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mvn package -D maven.test.skip=true docker:build -f pom.xml</span><br></pre></td></tr></table></figure></p>
<p>结果居然报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo，mvn command not found</span><br></pre></td></tr></table></figure></p>
<h1 id="解决sudo的问题"><a href="#解决sudo的问题" class="headerlink" title="解决sudo的问题"></a>解决sudo的问题</h1><p>上网查了下，原因是“系统预装的 sudo 在编译时缺省使用了 –with-secure-path 参数，因此当前用户使用 sudo 时环境变量 $PATH 被覆盖”，因此设置好的maven的环境变量被覆盖掉。如何处理呢？</p>
<h2 id="使用别名修改sudo"><a href="#使用别名修改sudo" class="headerlink" title="使用别名修改sudo"></a>使用别名修改sudo</h2><p>这是其中一个简单的解决办法，编辑当前用户的.bashrc 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>添加下面这行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias sudo=&quot;sudo env PATH=$PATH&quot;</span><br></pre></td></tr></table></figure></p>
<p>通过添加上面那行别名设置，就会在执行 sudo 时把当前的 $PATH 的值再套用上，达到想要的效果。然后编译一下.bashrc文件，再运行之前sudo mvn就能正常跑了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br><span class="line">$ sudo mvn package -D maven.test.skip=true docker:build -f pom.xml</span><br></pre></td></tr></table></figure></p>
<p>看上去是没问题了，但是如果把sudo man这句放到shell文件中执行，还是报<code>sudo，mvn command not found</code>，因此我们不使用别名这种方法了，改为用另一种：</p>
<h2 id="修改-etc-sudoers"><a href="#修改-etc-sudoers" class="headerlink" title="修改/etc/sudoers"></a>修改/etc/sudoers</h2><p>当前用户下我配置的环境变量是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/lib/jvm/java</span><br><span class="line">M2_HOME=/usr/local/maven3</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH=$PATH:$M2_HOME/bin</span><br></pre></td></tr></table></figure></p>
<p>我们用如下指令修改/etc/sudoers：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br></pre></td></tr></table></figure></p>
<p>然后用以下其中任意一种方法：</p>
<h3 id="修改secure-path"><a href="#修改secure-path" class="headerlink" title="修改secure_path"></a>修改secure_path</h3><p>找到<code>secure_path</code>那一行，例如它原来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure></p>
<p>我们改为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/lib/jvm/java/bin:/usr/local/maven3/bin</span><br></pre></td></tr></table></figure></p>
<p>修改后，即使在shell中执行sudo mvn也能正常跑了</p>
<h3 id="修改env-keep"><a href="#修改env-keep" class="headerlink" title="修改env_keep"></a>修改env_keep</h3><p>找到<code>env_keep</code>那一行，在它下边加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_keep += &quot;PATH&quot;</span><br></pre></td></tr></table></figure></p>
<p>修改后，即使在shell中执行sudo mvn也能正常跑了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/27/Docker容器的重启策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/27/Docker容器的重启策略/" itemprop="url">Docker容器的重启策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-27T15:48:08+08:00">
                2018-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Docker之前，传统的项目部署，也会遇到服务由于某种原因停了必须重新启动的情况。想象一下休息时间突然接到电话要求马上解决服务不正常的那种窘况，因此要让服务可以自行重启</p>
</blockquote>
<h1 id="Docker容器有什么重启策略"><a href="#Docker容器有什么重启策略" class="headerlink" title="Docker容器有什么重启策略"></a>Docker容器有什么重启策略</h1><ul>
<li>no，默认策略，在容器退出时不重启容器</li>
<li>on-failure，在容器非正常退出时（退出状态非0），才会重启容器。一般来说，手动的docker stop 容器名这样停止的容器，退出状态会是0。<ul>
<li>on-failure:3，在容器非正常退出时重启容器，最多重启3次</li>
</ul>
</li>
<li>always，在容器退出时总是重启容器</li>
<li>unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<h1 id="启动Docker镜像时设定重启策略"><a href="#启动Docker镜像时设定重启策略" class="headerlink" title="启动Docker镜像时设定重启策略"></a>启动Docker镜像时设定重启策略</h1><p>例如，我启动一个容器，我希望它每次非正常退出就自动重启服务，最多重启3次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name dict-web -d --restart=on-failure:3 tisson/dict-web-bid:latest</span><br></pre></td></tr></table></figure></p>
<h1 id="更新正在运行中的Docker容器的重启策略"><a href="#更新正在运行中的Docker容器的重启策略" class="headerlink" title="更新正在运行中的Docker容器的重启策略"></a>更新正在运行中的Docker容器的重启策略</h1><p>如果某Docker容器已在运行中，我希望在不停止该服务的情况下，把它设为可以自动重启，命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker update --restart=重启策略 &lt;container_id&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker update --restart=always dict-web</span><br></pre></td></tr></table></figure></p>
<p>假设某容器我们启动时设置了“总是重启”，那么如果我们手动停止它，它也会马上重启，因此我们在停止该重启前，也要用上边的方法，更改它的重启策略后，方能停止。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/27/用Docker构建、运行、发布一个SpringBoot应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/27/用Docker构建、运行、发布一个SpringBoot应用/" itemprop="url">用Docker构建、运行、发布一个SpringBoot应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-27T15:47:46+08:00">
                2018-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开发了一个Spring Boot的应用，传统的方法是打包（导出jar包），然后扔到服务器上，在服务器上配置好JDK等环境变量，然后运行jar包。现在改为用Docker了，希望每个jar包放在一个独立的容器，互不影响，要怎么做呢？<br>我们假设你用的是maven</p>
</blockquote>
<h1 id="Maven中加入Docker插件"><a href="#Maven中加入Docker插件" class="headerlink" title="Maven中加入Docker插件"></a>Maven中加入Docker插件</h1><p>修改工程的pom.xml文件，在如下位置加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ......&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">		                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">		                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">		                &lt;version&gt;0.4.11&lt;/version&gt;</span><br><span class="line">		                &lt;configuration&gt;</span><br><span class="line">		                    &lt;imageName&gt;$&#123;imagePath&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt;</span><br><span class="line">				&lt;!-- 工程中dockerfile的位置--&gt;</span><br><span class="line">		                    &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">		                    &lt;resources&gt;</span><br><span class="line">			                    &lt;resource&gt;</span><br><span class="line">			                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">			                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">			                            &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">			                    &lt;/resource&gt;</span><br><span class="line">		                    &lt;/resources&gt;</span><br><span class="line">		                &lt;/configuration&gt;</span><br><span class="line">		            &lt;/plugin&gt;</span><br><span class="line">......</span><br><span class="line">	&lt;profiles&gt;</span><br><span class="line">		&lt;profile&gt;</span><br><span class="line">			&lt;id&gt;自定的id&lt;/id&gt;</span><br><span class="line">			&lt;properties&gt;</span><br><span class="line">				&lt;imagePath&gt;自定的docker镜像前缀&lt;/imagePath&gt;</span><br><span class="line">			&lt;/properties&gt;</span><br><span class="line">		&lt;/profile&gt;</span><br><span class="line">	&lt;/profiles&gt;</span><br><span class="line">......</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h1><p>上边我们定义了docker file的位置：src/main/docker，因此，我们就在工程的该目录下，创建文件：Dockerfile，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from docker.io/openjdk:8u181       # 表示我们的docker镜像是基于openjdk:8u181构建的</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD helloworld-0.0.1-SNAPSHOT.jar app.jar      #其中“helloworld”对应pom.xml中的artifactId，“0.0.1-SNAPSHOT”对应pom.xml中的version，jar对应pom.xml中的packaging</span><br><span class="line">RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line">ENV JAVA_OPTS=&quot;&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -Duser.timezone=GMT+8 -jar /app.jar&quot; ]      # -Duser.timezone=GMT+8这句是设置docker使用北京、上海的这个时区</span><br></pre></td></tr></table></figure></p>
<h1 id="构建Docker-Image"><a href="#构建Docker-Image" class="headerlink" title="构建Docker Image"></a>构建Docker Image</h1><p>这一步把工程通过maven构建为一个docker镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -D maven.test.skip=true -P 【上边自定的profile id】 docker:build -f pom.xml</span><br></pre></td></tr></table></figure></p>
<p>这时，我们通过docker images命令可以看到创建的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tisson/dict                latest              6febabde1fc5        6 hours ago         836 MB</span><br></pre></td></tr></table></figure></p>
<p>tisson/dict 就是之前定义的imageName：${imagePath}/${project.artifactId}</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>然后就像运行一般docker容器那样即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d tisson/dict:latest</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/备份Docker-MySQL镜像的数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/备份Docker-MySQL镜像的数据/" itemprop="url">备份Docker MySQL镜像的数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-04T20:06:51+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Docker容器关闭（删除）后，数据会消失。为此我们需用到Docker的挂载。那么现在如果我们要再多做一步，每天备份Docker MYSQL镜像的数据呢？</p>
</blockquote>
<h1 id="使用挂载功能"><a href="#使用挂载功能" class="headerlink" title="使用挂载功能"></a>使用挂载功能</h1><p>我们把MySQL Docker容器中用到的目录挂载到宿主机上的目录： -v 主机路径:容器内部路径<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name mysql57 -v /mnt/data-disk/mysql1/config:/etc/mysql/conf.d -v /mnt/data-disk/mysql1/datadir:/var/lib/mysql -v /etc/localtime:/etc/localtime:ro -m 2G --memory-swap=2G -e MYSQL_ROOT_PASSWORD=&apos;ROOT用户的密码&apos; -p 3308:3306 -d docker.io/mysql:5.7.23 --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci</span><br></pre></td></tr></table></figure></p>
<h1 id="备份数据的脚本"><a href="#备份数据的脚本" class="headerlink" title="备份数据的脚本"></a>备份数据的脚本</h1><h2 id="MySQL的备份脚本"><a href="#MySQL的备份脚本" class="headerlink" title="MySQL的备份脚本"></a>MySQL的备份脚本</h2><p>格式如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p密码 数据库名 &gt; 导出的文件名（自行定义，例如test.dump）</span><br><span class="line"># 注意-p和密码之间不要留空格（留了也许可以，但有时会报错）</span><br></pre></td></tr></table></figure></p>
<h2 id="Docker-MySQL镜像的备份脚本"><a href="#Docker-MySQL镜像的备份脚本" class="headerlink" title="Docker MySQL镜像的备份脚本"></a>Docker MySQL镜像的备份脚本</h2><p>脚本如下<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i $(docker ps -aqf &quot;name=xxxx&quot;) mysqldump -u root -p&apos;root用户密码&apos; --ignore-table=xxx.aaa 数据库名 &gt; 文件名</span><br><span class="line"># 注意不要有-t，因为-t是分配一个伪终端,但是crontab执行的时候实际是不需要的</span><br></pre></td></tr></table></figure></p>
<p>例如，我们刚才创建了一个名为mysql57的MySQL Docker容器，我们设置了它的root密码是ab(c)，我们希望可以备份到一个根据当前日期决定的文件名<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i $(docker ps -aqf &quot;name=mysql57&quot;) mysqldump -u root -p&apos;ab(c)&apos; dict &gt; /mnt/data-disk/dict-$(date +%Y%m%d).dump</span><br></pre></td></tr></table></figure></p>
<h1 id="使用Linux的定时功能，定时备份数据"><a href="#使用Linux的定时功能，定时备份数据" class="headerlink" title="使用Linux的定时功能，定时备份数据"></a>使用Linux的定时功能，定时备份数据</h1><p>需要用到crontab，如果没安装，需要先安装  </p>
<h2 id="编写脚本文件"><a href="#编写脚本文件" class="headerlink" title="编写脚本文件"></a>编写脚本文件</h2><p>假设我们要执行的脚本文件是/root/dockerfiles/script/data_bak.sh<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件</span><br><span class="line">$ touch data_bak.sh</span><br><span class="line"># 赋予执行权限</span><br><span class="line">$ chmod 755 data_bak.sh</span><br></pre></td></tr></table></figure></p>
<p>在文件中写入如下语句<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i $(docker ps -aqf &quot;name=mysql57&quot;) mysqldump -u root -p&apos;ab(c)&apos; dict &gt; /mnt/data-disk/dict-$(date +%Y%m%d).dump</span><br></pre></td></tr></table></figure></p>
<h2 id="编辑定时执行计划"><a href="#编辑定时执行计划" class="headerlink" title="编辑定时执行计划"></a>编辑定时执行计划</h2><p>执行<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure></p>
<p>然后在文件中添加：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * * sh /root/dockerfiles/script/data_bak.sh &gt;&gt; /mnt/data-disk/mysql_dumps.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>前面5个参数分别表示分钟、小时、日、月、年，星号表示任意</p>
<p>就这样，每天凌晨3点，数据会备份到/mnt/data-disk/ 目录下的dict-当前日期.dump</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/Docker基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/Docker基本操作/" itemprop="url">Docker基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T09:42:40+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>貌似应该装Docker CE版，不过这里我直接装Docker，不知道算是CE（社区）版还是EE（企业）版。  </p>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>以CentOS为例，内核版本需要3.10以上：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">3.10.0-862.el7.x86_64</span><br></pre></td></tr></table></figure></p>
<h2 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h2><p>以CentOS为例（新版的Docker分为企业版和社区版了，以下安装方式安装的版本会比较旧）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install docker</span><br></pre></td></tr></table></figure></p>
<h3 id="安装Docker-CE（社区版）"><a href="#安装Docker-CE（社区版）" class="headerlink" title="安装Docker CE（社区版）"></a>安装Docker CE（社区版）</h3><p>最新版的以CentOS为例，如果安装了旧版本的，可以先卸载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove docker \</span><br><span class="line">	docker-common \</span><br><span class="line">	docker-selinux \</span><br><span class="line">	docker-engine</span><br></pre></td></tr></table></figure></p>
<p>安装以下依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></p>
<p>添加国内软件源，加快速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p>
<p>安装Docker CE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure></p>
<h1 id="Docker寻找镜像资源"><a href="#Docker寻找镜像资源" class="headerlink" title="Docker寻找镜像资源"></a>Docker寻找镜像资源</h1><p>官方的仓库，直接上去搜，可以看到各个镜像资源的说明，还有资源的各个tag：<br><a href="https://hub.docker.com/search/" target="_blank" rel="noopener">https://hub.docker.com/search/</a></p>
<h1 id="Docker运行"><a href="#Docker运行" class="headerlink" title="Docker运行"></a>Docker运行</h1><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><p>其实就是看看版本号<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure></p>
<h2 id="使用国内镜像资源"><a href="#使用国内镜像资源" class="headerlink" title="使用国内镜像资源"></a>使用国内镜像资源</h2><p>针对国内下载慢的问题：<br>修改/etc/docker/ 目录下的daemon.json，加入如下语句（注意，大括号是文件内默认已经有的，不用加）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后需要重启服务端</p>
<h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><p>要使用Docker，需要启动Docker服务端<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service docker start</span><br></pre></td></tr></table></figure></p>
<p>CentOS 7.0以上系统也可以这样<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start docker.service</span><br></pre></td></tr></table></figure></p>
<h2 id="设置Docker为开机启动"><a href="#设置Docker为开机启动" class="headerlink" title="设置Docker为开机启动"></a>设置Docker为开机启动</h2><p>两种方式（第2种为CentOS7.0以上版本）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig docker on</span><br><span class="line"></span><br><span class="line">$ systemctl enable docker.service</span><br></pre></td></tr></table></figure></p>
<h2 id="停止Docker服务端"><a href="#停止Docker服务端" class="headerlink" title="停止Docker服务端"></a>停止Docker服务端</h2><p>停止<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service docker stop</span><br></pre></td></tr></table></figure></p>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>例如我们要下载mysql 5.7.23<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7.23</span><br></pre></td></tr></table></figure></p>
<p>又例如我们要下载tomcat最新版<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull tomcat:latest</span><br></pre></td></tr></table></figure></p>
<h2 id="查看已下载的镜像"><a href="#查看已下载的镜像" class="headerlink" title="查看已下载的镜像"></a>查看已下载的镜像</h2><p>运行docker images，效果如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/tomcat           latest              41a54fe1f79d        2 weeks ago         463 MB</span><br><span class="line">docker.io/mysql            5.7.23              563a026a1511        3 weeks ago         372 MB</span><br></pre></td></tr></table></figure></p>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>例如我们要运行tomcat：<br>    ```<br>    $ docker run docker.io/tomcat:latest<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样就会在前台运行tomcat服务器，然后我们可以按CTRL+C终止。  </span><br><span class="line">### 后台运行镜像</span><br><span class="line">我们也可以让tomcat在后台运行</span><br></pre></td></tr></table></figure></p>
<pre><code>$ docker run -d docker.io/tomcat:latest
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会得到一串字符，这个就是容器运行的ID。</span><br></pre></td></tr></table></figure>

1c5cf21627fbc03d5674a2145b7de206b736b2a4aa006c64dc848762558a1725
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 带参数配置的运行</span><br><span class="line">例如我们运行mysql，需要给它指定初始密码（root用户密码），需要指定开放出来的端口号（注意容器内的端口号与容器外对应的端口号，我们在容器外部要连mysql，需要访问的是mysql容器外对应的端口号）</span><br></pre></td></tr></table></figure>

$ docker run --name 任意名字例如mysql57 -e MYSQL_ROOT_PASSWORD=设置root用户的密码 -p 主机端口号:容器端口号 -d docker.io/mysql:5.7.23
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们知道mysql默认使用的端口号是3306，容器内mysql使用的端口也正是3306，而下边的命令我们设置了主机上的3307端口映射到容器内的3306端口，那么我们要访问mysql就需要从3307端口而不是3306端口了。</span><br></pre></td></tr></table></figure>

$ docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 -p 3307:3306 -d docker.io/mysql:5.7.23 --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 进入正在运行的容器内部</span><br><span class="line">docker exec 【options】【容器名（不用写全）】【命令】【命令参数】</span><br></pre></td></tr></table></figure>

$ docker exec -it 370b0ee1f169 bash
或者
$ docker exec -it e1066fe2db35 /bin/bash
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入容器后可以通过输入exit退出容器内</span><br><span class="line">## 列出正在运行的容器</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

$ docker ps
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回</span><br></pre></td></tr></table></figure>
</code></pre><p>CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS                      PORTS                                                      NAMES<br>370b0ee1f169        neo4j                            “/sbin/tini -g – …”   19 hours ago        Up 19 hours                 0.0.0.0:7474-&gt;7474/tcp, 7473/tcp, 0.0.0.0:7687-&gt;7687/tcp   jolly_swanson<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 列出所有容器</span><br><span class="line">包括已经停止的</span><br><span class="line">`$ docker ps -a`  </span><br><span class="line">返回</span><br></pre></td></tr></table></figure></p>
<p>CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS                      PORTS                                                      NAMES<br>370b0ee1f169        neo4j                            “/sbin/tini -g – …”   19 hours ago        Up 19 hours                 0.0.0.0:7474-&gt;7474/tcp, 7473/tcp, 0.0.0.0:7687-&gt;7687/tcp   jolly_swanson<br>f2da9237003f        docker.io/tomcat:latest          “catalina.sh run”        19 hours ago        Exited (143) 19 hours ago                                                              confident_noyce<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 停止容器运行</span><br><span class="line">我们想停止正在运行的neo4j容器，它的ID是370b0ee1f169，注意执行命令时ID不用写全</span><br></pre></td></tr></table></figure></p>
<pre><code>$ docker stop 370b0ee1f169
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 重新启动已停止运行的容器</span><br><span class="line">例如我想重新启动之前停止了的tomcat，它的ID是f2da9237003f，注意执行命令的时候，ID不用写全，例如只写f2d也是可以的</span><br></pre></td></tr></table></figure>

$ docker start f2da9237003f
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 移除容器</span><br><span class="line">移除容器之前，该容器必须已停止运行</span><br></pre></td></tr></table></figure>

$ docker rm 容器ID
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 卸载镜像</span><br><span class="line">移除镜像之前，必须移除所有该镜像的容器</span><br></pre></td></tr></table></figure>

$ docker rmi 镜像ID
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 【示例】Docker下修改mysql配置文件</span><br><span class="line">由于需要修改mysql的sql\_mode，在命令行修改每次重启都会失效，因为修改docker下mysql的配置文件，假设正在运行的MySQL容器ID为e1066fe2db35。  </span><br><span class="line">进入容器：</span><br></pre></td></tr></table></figure>

$ docker exec -it e1066fe2db35 /bin/bash
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置文件在容器内的这个位置：`/etc/mysql/mysql.conf.d/mysqld.cnf`</span><br><span class="line">直接修改只对容器有用，对镜像本身没用。如果我们想在镜像运行时使用我们想用的配置的话：</span><br></pre></td></tr></table></figure>

docker run -d -p 3306:3306 -v /soft/mysql/my.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /soft/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql57 mysql:5.7.23
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以看到用了-v，我们指定使用主机上的/soft/mysql/my.cnf映射到（替换）容器内的/etc/mysql/mysql.conf.d/mysqld.cnf，用主机上的/soft/mysql/data映射到容器内的/var/lib/mysql（这个是容器内mysql的datadir），这样就可以让容器内的mysql使用容器外（主机）上的数据文件。</span><br><span class="line"></span><br><span class="line"># Docker Container的导入导出</span><br><span class="line">导出容器，用ID或names(别名，自定义的)皆可，例如：</span><br></pre></td></tr></table></figure>

$ docker export 011b39e7f806 &gt; ~/Downloads/mysql.tar
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在导出后，你可以把文件利用scp或是ftp等各种方式分发，然后这样导入：</span><br></pre></td></tr></table></figure>

$ docker import - /Users/SeaMonster/Downloads/mysql.tar
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Docker 镜像的保存/加载</span><br><span class="line">保存/加载与导出导入有一些类似</span><br><span class="line">- export/import与 save/load区别</span><br><span class="line">	- export/import 是根据容器来导出镜像（因此没有镜像的历史记录）而 save/load 操作的对象是镜像</span><br><span class="line">	- export/import 镜像的历史记录再导后无法进行回滚操作，而save/load镜像有完整的历史记录可以回滚</span><br><span class="line"></span><br><span class="line">保存镜像：</span><br></pre></td></tr></table></figure>

$ docker save mysql:5.7.23 &gt; mysql.tar
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载本地镜像</span><br></pre></td></tr></table></figure>

$ docker load -i mysql.tar
```
</code></pre><h1 id="Docker-制作镜像"><a href="#Docker-制作镜像" class="headerlink" title="Docker 制作镜像"></a>Docker 制作镜像</h1><h2 id="手工生成方式"><a href="#手工生成方式" class="headerlink" title="手工生成方式"></a>手工生成方式</h2><p>【待补充】，参考<a href="https://blog.csdn.net/u013378306/article/details/54021638" target="_blank" rel="noopener">https://blog.csdn.net/u013378306/article/details/54021638</a></p>
<h2 id="Dockerfile方式"><a href="#Dockerfile方式" class="headerlink" title="Dockerfile方式"></a>Dockerfile方式</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/以太坊Dapp开发（一）-环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/以太坊Dapp开发（一）-环境搭建/" itemprop="url">以太坊Dapp开发（一）--环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T22:25:31+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>说到环境搭建嘛，所有的开发首先都离不开这一步，熟悉了真不难，不过第一次接触真是觉得它又长又臭无聊又无趣，需要装一大堆听都没听过的东西，毕竟开源的通常都这德行，基本不用指望有人给你提供个“一键安装”的整合包，足以吓走90%的人。不过也无需太担心，某种程度上这是可以用钱解决的问题，如果手头上有点闲钱，可以话个200元去【汇智网】学一个Dapp开发的课程，虽然它的课其实不怎么样，助教水平也不算高不过勉强能帮你解答入门时期的困惑，最关键是帮你搭建了环境，让你可以直接使用。当你看到了环境搭建好的效果后，自己再搭建就会更有信心、更有动力一些</p>
</blockquote>
<h1 id="我们到底要干什么"><a href="#我们到底要干什么" class="headerlink" title="我们到底要干什么"></a>我们到底要干什么</h1><p>回想一下我们之前开发一个最终部署到生产环境的应用是怎么样的。以JAVA WEB为例，本地开发后，把代码打包成jar包，部署到线上的服务器，一般情况下，我们的JAVA WEB服务还要连上一个或多个数据库。然后我们需要把这些JAVA WEB服务还有数据库部署到服务器。而这个（些）服务器，一般是私人的，绝大部分人没有权限获知服务器任何信息，而你部署上去的这个jar包，其他人也不清楚里边的逻辑，对于他们而言，整个服务就是一个黑箱，他们也无需关注内里逻辑，能用就行。至于数据呢，全部自己掌控，想怎么改就怎么改。<br>现在我们需要开发DApp（Dapp分为客户端、服务端。客户端可以直接理解为一个WEB应用，我们这系列文章更关注其服务端，也就是智能合约部分），我们把它跟之前开发JAVA WEB服务一一类比，以便理解：</p>
<ol>
<li>之前我们开发JAVA WEB，用的是Java语言。而我们准备开发的智能合约，用的是Solidity语言</li>
<li>开发Java我们需要开发环境（用来编译啊、执行啊、打包啊）：JDK。而我们准备开发的Solidity，同样也需要开发环境：solc。</li>
<li>开发Java我们会用到IDE，而不是用记事本那么寒酸吧。开发Java我们会用IDEA啦、Eclipse什么的。而开发智能合约，我们使用名为“remix-ide”的IDE。</li>
<li>开发Java Web我们通常会连数据库，有关系型数据库啦、NoSQL啦、五花八门。而智能合约呢，抱歉没这个东西，数据直接存放到智能合约的运行环境中。想象一下Java程序不可以连外部数据库、外部服务器、外部文件，那数据只能存放到JVM中，而智能合约也类似，不过换了个名称：EVM。</li>
<li>Java Web服务我们需要部署到一个Web容器它才能跑，例如Tomcat啦、Jetty啦。如果我们希望这个Java Web服务能被互联网上所有人访问到，方法数不胜数，找个阿里云啊腾讯云什么的、或者随便找个什么机房，总之是提供公网访问的服务器，扔上去就可以了。 至于我们准备开发的智能合约呢，本地部署还真有几种类似“Tomcat”这种东西，我只说其中一个：Ganache。如果我们希望合约被互联网上所有人访问呢，呃，貌似只有一个途径：部署到以太坊的网络（我们说的是以太坊，所以什么EOS的，先忽略）。</li>
</ol>
<p><strong>综上所述、我们大概是要安装一个类似JDK的东西：solc；一个类似IDEA或者Eclipse的东西：remix-ode、一个类似Tomcat的东西：Ganache</strong></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装solc"><a href="#安装solc" class="headerlink" title="安装solc"></a>安装solc</h2><p>安装solc需要使用npm（ Node.js 平台的默认包管理工具），而使用nam就需要先安装node.js。【注：新版的node.js已经集成了npm】安装node.js与npm的过程略去不表，这里只说下一些可能是坑的地方：</p>
<ol>
<li>node.js最低要求7.10.1以上，npm最低要求4.2.0以上，过低的需要升级，否则无法安装solc和remix-ide。</li>
<li>熟知java开发的清楚这个包管理器npm类似maven，需要连网上的中央仓库下载各种依赖包。这个中央仓库是在国外的，速度比较慢。解决办法有A：使用“镜像”源— 国内的阿里提供的，百度一下即可。B：翻墙。其中B比较省事，少了些坑。</li>
</ol>
<p>安装好npm，后，运行以下指令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g solc</span><br></pre></td></tr></table></figure></p>
<p>实际安装的貌似是solcjs而不是solc。两者到底有什么区别，我在网上就没看到说得清楚的文章，反正在我机子上，按字面理解我是安装solc，但实际应用时，还是必须用solcjs。</p>
<h2 id="安装remix-ide"><a href="#安装remix-ide" class="headerlink" title="安装remix-ide"></a>安装remix-ide</h2><p>有2种版本：在线版和离线版  </p>
<h3 id="在线版"><a href="#在线版" class="headerlink" title="在线版"></a>在线版</h3><p>直接打开<a href="https://remix.ethereum.org/" title="https://remix.ethereum.org" target="_blank" rel="noopener">https://remix.ethereum.org</a> 无需安装，打开链接即可使用。在国内访问会有些慢，可以考虑翻墙。  </p>
<h3 id="离线版"><a href="#离线版" class="headerlink" title="离线版"></a>离线版</h3><p>本机启动、无需连网。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>有两种安装方式：<br>方法一：使用npm安装<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install remix-ide -g</span><br></pre></td></tr></table></figure></p>
<p>如果出现错误：Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’，可以尝试以下方法解决：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：remix-ide的github 上还提供了另一个方法进行安装，通过clone 代码来安装<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/ethereum/remix-ide.git</span><br><span class="line">$ cd remix-ide</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run setupremix  # this will clone https://github.com/ethereum/remix for you and link it to remix-ide</span><br><span class="line">$ npm start #这句其实是运行remix-ide了</span><br></pre></td></tr></table></figure></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行以下语句：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ remix-ide</span><br></pre></td></tr></table></figure></p>
<p>然后浏览器打开<a href="http://localohost:8080即可打开ide。" target="_blank" rel="noopener">http://localohost:8080即可打开ide。</a><br>可以看到它默认端口是8080，如果我们需要换一个端口呢？<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ which remix-ide</span><br><span class="line">/usr/local/bin/remix-ide</span><br><span class="line">$ cd /usr/local/bin/</span><br><span class="line">$ vi remix-ide</span><br></pre></td></tr></table></figure></p>
<p>可以看到一行 <code>server.listen(8080, &#39;127.0.0.1&#39;, function () {})</code>，把那个8080改为任意端口。当然，最好把下边那句console.log的端口也改了，免得打印的信息误导用户。</p>
<h2 id="安装Ganache"><a href="#安装Ganache" class="headerlink" title="安装Ganache"></a>安装Ganache</h2><p>打开<a href="https://truffleframework.com/ganache" target="_blank" rel="noopener">https://truffleframework.com/ganache</a>（需翻墙），下载，安装，运行。它除了让我们可以部署合约外，它自己默认提供了10个钱包账号（钱包账号数目可以调整，例如调为100），每个账号默认有100个以太币。当我们部署合约、修改合约内的数据时，需要消耗这些以太币。</p>
<h2 id="安装Metamask"><a href="#安装Metamask" class="headerlink" title="安装Metamask"></a>安装Metamask</h2><p>一个Chrome/Firefox的插件，安装需翻墙。除了用于开发外，也可用于实际支付。反正必须装。</p>
<p>至此，开发所需环境搭建完毕。注意以上所需环境也可以“变更”，例如我用Ganache-cli，直接用命令行而不是一个Ganache的App，又或者用Mist代替Metamask，本人实在懒得理会这些替代方案了，本人的目标是尽快弄一个Dapp并上线，能跳过的尽量跳过，不想纠缠。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/以太坊Dapp开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/以太坊Dapp开发/" itemprop="url">以太坊Dapp开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T12:02:54+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>不包含UI部分开发</p>
</blockquote>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h1 id="编写Solidity合约"><a href="#编写Solidity合约" class="headerlink" title="编写Solidity合约"></a>编写Solidity合约</h1><h1 id="部署合约到生产-测试环境"><a href="#部署合约到生产-测试环境" class="headerlink" title="部署合约到生产/测试环境"></a>部署合约到生产/测试环境</h1><h1 id="使用Web3j与合约通信"><a href="#使用Web3j与合约通信" class="headerlink" title="使用Web3j与合约通信"></a>使用Web3j与合约通信</h1><h1 id="补充：智能合约的优化"><a href="#补充：智能合约的优化" class="headerlink" title="补充：智能合约的优化"></a>补充：智能合约的优化</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/Linux-SSH远程免密码登录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/Linux-SSH远程免密码登录/" itemprop="url">Linux SSH远程免密码登录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T11:38:31+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>远程登录Linux服务器，或者往其上传文件，每次都要输入一大串密码，而且密码还不能复制，相当麻烦，有没办法保存密码不用每次输入呢？</p>
</blockquote>
<h1 id="在本机（Linux-macOS-）上生成密钥"><a href="#在本机（Linux-macOS-）上生成密钥" class="headerlink" title="在本机（Linux/macOS ）上生成密钥"></a>在本机（Linux/macOS ）上生成密钥</h1><p>执行命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p>
<p>然后按提示操作，在位置所有默认设置的情况下，该命令会在<strong>用户的根目录</strong>（例如/root/）生成.ssh文件夹，里边会有如下文件：  </p>
<ul>
<li>authorized_keys:存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥</li>
<li>id_rsa : 生成的私钥文件</li>
<li>id_rsa.pub ： 生成的公钥文件</li>
<li>know_hosts : 已知的主机公钥清单</li>
</ul>
<h1 id="把公钥添加到要被远程登录的服务器"><a href="#把公钥添加到要被远程登录的服务器" class="headerlink" title="把公钥添加到要被远程登录的服务器"></a>把公钥添加到要被远程登录的服务器</h1><p>如果希望ssh公钥生效需满足至少下面两个条件：  </p>
<ol>
<li>.ssh目录的权限必须至少是700</li>
<li>.ssh/authorized_keys文件权限必须至少是600</li>
</ol>
<p>添加的方式也有如下几种，使用其中一种即可。</p>
<h2 id="通过ssh-copy-id的方式"><a href="#通过ssh-copy-id的方式" class="headerlink" title="通过ssh-copy-id的方式"></a>通过ssh-copy-id的方式</h2><p>将本机的公钥复制到远程机器的authorized_keys文件中，ssh-copy-id也能让你有到远程机器的home, ./ssh , 和 /.ssh/authorized_keys的权利<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;remote-host&gt;</span><br></pre></td></tr></table></figure></p>
<p>remote-host就是远程服务器ip，例如132.121.30.70  。<br>这里需要按提示输入该远程服务器的密码。<br><strong>注意</strong></p>
<ul>
<li>客户端与服务端将使用同一个用户名，例如本地使用的是user1用户，那么请确保远程服务端也有user1用户并有足够权限。</li>
<li>要求该远程服务器安装了ssh，否则会报错“-bash: ssh-copy-id: command not found ”。如果该服务器是CentOS我们可以通过“<code>yum -y install openssh-clients</code>”来安装。</li>
</ul>
<h2 id="通过scp将内容写到对方的文件中"><a href="#通过scp将内容写到对方的文件中" class="headerlink" title="通过scp将内容写到对方的文件中"></a>通过scp将内容写到对方的文件中</h2><p>运行如下命令：  （remote_ip就是远程服务器ip，例如132.121.30.70，然后输入远程服务器的密码。）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub root@&lt;remote_ip&gt;:pub_key #将文件拷贝至远程服务器（root为远程服务器用户名，可使用其他）</span><br><span class="line"># 登录远程服务器，然后：</span><br><span class="line">$ cat ~/pub_key &gt;&gt;~/.ssh/authorized_keys  # 将内容追加到authorized_keys文件中， 需要登录远程服务器来执行这条命令</span><br></pre></td></tr></table></figure></p>
<h2 id="通过Ansible实现批量免密（以后补充）"><a href="#通过Ansible实现批量免密（以后补充）" class="headerlink" title="通过Ansible实现批量免密（以后补充）"></a>通过Ansible实现批量免密（以后补充）</h2><h2 id="手工复制粘贴的方式"><a href="#手工复制粘贴的方式" class="headerlink" title="手工复制粘贴的方式"></a>手工复制粘贴的方式</h2><p>将本地id_rsa.pub文件的内容拷贝至远程服务器的/.ssh/authorized_keys文件中</p>
<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>（1）SELinux需关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getenforce</span><br><span class="line">Disabled</span><br></pre></td></tr></table></figure></p>
<p>（2）/etc/ssh/sshd_config文件的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StrictModes yes</span><br><span class="line"># 上面这句需要注释掉或改为StrictModes no，否则不能免密</span><br></pre></td></tr></table></figure></p>
<h1 id="常见问题失败原因"><a href="#常见问题失败原因" class="headerlink" title="常见问题失败原因"></a>常见问题失败原因</h1><h2 id="某次无法免密的原因定位及最终解决办法"><a href="#某次无法免密的原因定位及最终解决办法" class="headerlink" title="某次无法免密的原因定位及最终解决办法"></a>某次无法免密的原因定位及最终解决办法</h2><p>我在本机远程登录某台Linux服务器，已按照本文上述办法配置了keys，登录远程服务器时如果用的是远程服务器的root账号，可以免密，使用另一个账号，死活让我输入密码。</p>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><h4 id="使用ssh-vvv"><a href="#使用ssh-vvv" class="headerlink" title="使用ssh -vvv"></a>使用ssh -vvv</h4><p>使用ssh 加上-vvv参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -vvv tisson@tisson_s1</span><br><span class="line">......</span><br><span class="line">debug1: SSH2_MSG_SERVICE_ACCEPT received</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_rsa (0x7fb9db700300),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_dsa (0x0),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_ecdsa (0x0),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_ed25519 (0x0),</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password</span><br><span class="line">debug3: start over, passed a different list publickey,gssapi-keyex,gssapi-with-mic,password</span><br><span class="line">debug3: preferred publickey,keyboard-interactive,password</span><br><span class="line">debug3: authmethod_lookup publickey</span><br><span class="line">debug3: remaining preferred: keyboard-interactive,password</span><br><span class="line">debug3: authmethod_is_enabled publickey</span><br><span class="line">debug1: Next authentication method: publickey</span><br><span class="line">debug1: Offering RSA public key: /Users/SeaMonster/.ssh/id_rsa</span><br><span class="line">debug3: send_pubkey_test</span><br><span class="line">debug2: we sent a publickey packet, wait for reply</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password</span><br><span class="line">debug1: Trying private key: /Users/SeaMonster/.ssh/id_dsa</span><br><span class="line">debug3: no such identity: /Users/SeaMonster/.ssh/id_dsa: No such file or directory</span><br><span class="line">debug1: Trying private key: /Users/SeaMonster/.ssh/id_ecdsa</span><br><span class="line">debug3: no such identity: /Users/SeaMonster/.ssh/id_ecdsa: No such file or directory</span><br><span class="line">debug1: Trying private key: /Users/SeaMonster/.ssh/id_ed25519</span><br><span class="line">debug3: no such identity: /Users/SeaMonster/.ssh/id_ed25519: No such file or directory</span><br><span class="line">debug2: we did not send a packet, disable method</span><br><span class="line">debug3: authmethod_lookup password</span><br><span class="line">debug3: remaining preferred: ,password</span><br><span class="line">debug3: authmethod_is_enabled password</span><br><span class="line">debug1: Next authentication method: password</span><br><span class="line">......</span><br><span class="line">tisson@tisson_s1&apos;s password:</span><br></pre></td></tr></table></figure></p>
<p>如果使用root账号登录则成功免密，打印出来的信息应该是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@tisson_s1</span><br><span class="line">......</span><br><span class="line">debug1: SSH2_MSG_SERVICE_ACCEPT received</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_rsa (0x7fde8b6001e0),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_dsa (0x0),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_ecdsa (0x0),</span><br><span class="line">debug2: key: /Users/SeaMonster/.ssh/id_ed25519 (0x0),</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password</span><br><span class="line">debug3: start over, passed a different list publickey,gssapi-keyex,gssapi-with-mic,password</span><br><span class="line">debug3: preferred publickey,keyboard-interactive,password</span><br><span class="line">debug3: authmethod_lookup publickey</span><br><span class="line">debug3: remaining preferred: keyboard-interactive,password</span><br><span class="line">debug3: authmethod_is_enabled publickey</span><br><span class="line">debug1: Next authentication method: publickey</span><br><span class="line">debug1: Offering RSA public key: /Users/SeaMonster/.ssh/id_rsa</span><br><span class="line">debug3: send_pubkey_test</span><br><span class="line">debug2: we sent a publickey packet, wait for reply</span><br><span class="line">debug1: Server accepts key: pkalg ssh-rsa blen 279</span><br><span class="line">debug2: input_userauth_pk_ok: fp SHA256:AsKItChwZM65IafPmkuAYHB26hPOaLRh5Dgx5uTMeJY</span><br><span class="line">debug3: sign_and_send_pubkey: RSA SHA256:AsKItChwZM65IafPmkuAYHB26hPOaLRh5Dgx5uTMeJY</span><br><span class="line">debug1: Authentication succeeded (publickey).</span><br><span class="line">Authenticated to tisson_s1 ([172.16.28.226]:22).</span><br><span class="line">debug1: channel 0: new [client-session]</span><br><span class="line">debug3: ssh_session2_open: channel_new: 0</span><br><span class="line">debug2: channel 0: send open</span><br><span class="line">debug1: Requesting no-more-sessions@openssh.com</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug2: callback start</span><br><span class="line">debug2: fd 3 setting TCP_NODELAY</span><br><span class="line">debug3: ssh_packet_set_tos: set IP_TOS 0x10</span><br><span class="line">debug2: client_session2_setup: id 0</span><br><span class="line">debug2: channel 0: request pty-req confirm 1</span><br><span class="line">debug1: Sending environment.</span><br><span class="line">debug3: Ignored env TERM_PROGRAM</span><br><span class="line">debug3: Ignored env TERM</span><br><span class="line">debug3: Ignored env SHELL</span><br><span class="line">debug3: Ignored env HOMEBREW_BOTTLE_DOMAIN</span><br><span class="line">debug3: Ignored env TMPDIR</span><br><span class="line">debug3: Ignored env Apple_PubSub_Socket_Render</span><br><span class="line">debug3: Ignored env TERM_PROGRAM_VERSION</span><br><span class="line">debug3: Ignored env TERM_SESSION_ID</span><br><span class="line">debug3: Ignored env USER</span><br><span class="line">debug3: Ignored env COMMAND_MODE</span><br><span class="line">debug3: Ignored env SSH_AUTH_SOCK</span><br><span class="line">debug3: Ignored env __CF_USER_TEXT_ENCODING</span><br><span class="line">debug3: Ignored env PATH</span><br><span class="line">debug3: Ignored env PWD</span><br><span class="line">debug1: Sending env LANG = zh_CN.UTF-8</span><br><span class="line">debug2: channel 0: request env confirm 0</span><br><span class="line">debug3: Ignored env ITERM_PROFILE</span><br><span class="line">debug3: Ignored env XPC_FLAGS</span><br><span class="line">debug3: Ignored env XPC_SERVICE_NAME</span><br><span class="line">debug3: Ignored env SHLVL</span><br><span class="line">debug3: Ignored env HOME</span><br><span class="line">debug3: Ignored env COLORFGBG</span><br><span class="line">debug3: Ignored env ITERM_SESSION_ID</span><br><span class="line">debug3: Ignored env LOGNAME</span><br><span class="line">debug3: Ignored env SECURITYSESSIONID</span><br><span class="line">debug3: Ignored env _</span><br><span class="line">debug3: Ignored env OLDPWD</span><br><span class="line">debug2: channel 0: request shell confirm 1</span><br><span class="line">debug2: callback done</span><br><span class="line">debug2: channel 0: open confirm rwindow 0 rmax 32768</span><br><span class="line">debug2: channel_input_status_confirm: type 99 id 0</span><br><span class="line">debug2: PTY allocation request accepted on channel 0</span><br><span class="line">debug2: channel 0: rcvd adjust 2097152</span><br><span class="line">debug2: channel_input_status_confirm: type 99 id 0</span><br><span class="line">debug2: shell request accepted on channel 0</span><br></pre></td></tr></table></figure></p>
<p>为什么会这样呢？</p>
<h4 id="查看-var-log-secure中的日志"><a href="#查看-var-log-secure中的日志" class="headerlink" title="查看/var/log/secure中的日志"></a>查看/var/log/secure中的日志</h4><p>在当中发现这么一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authentication refused: bad ownership or modes for directory home/tisson</span><br></pre></td></tr></table></figure></p>
<p>很明显，该目录的权限配置有问题。sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。用户目录权限为 755 或者 700，就是不能是77x。<strong>给高了反而失败！</strong><br>。要远程免密登录，几个文件、目录的权限要求如下：</p>
<ul>
<li>/home/当前用户：700权限</li>
<li>~/.ssh：700权限</li>
<li>~/.ssh/authorized_keys：600或644权限<br>重新调整权限后，免密登录成功。</li>
</ul>
<p>参考：<br><a href="http://blog.chinaunix.net/uid-26284395-id-2949145.html" title="使用ssh-keygen和ssh-copy-id三步实现SSH无密码登录" target="_blank" rel="noopener"> 使用ssh-keygen和ssh-copy-id三步实现SSH无密码登录 </a><br><a href="https://www.cnblogs.com/yixue2017/p/7559970.html" title="Linux下实现免密码登录(超详细)" target="_blank" rel="noopener">Linux下实现免密码登录(超详细)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sea Monster</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sea Monster</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
