<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="量">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="量">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="量">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>量</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">量</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/08/pymysql获取新插入数据的id/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/08/pymysql获取新插入数据的id/" itemprop="url">pymysql获取新插入数据的id</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T14:49:59+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>MySQL数据表字段为自增长，当我们往该表添加记录时，自增长列会自行填充数据，但是如何获取它自行填充的值呢？</p>
</blockquote>
<p>例如我有一个数据表<code>t_generate_id</code>，里边就一个字段：自增长列<code>id</code>。我们使用的是<code>pymysql</code>，每次往表新增数据时获取刚才新增记录的id值，最简单的方法如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pymsql</span><br><span class="line">conn = pymysql.connect(host=&apos;172.16.27.40&apos;, user=&apos;test&apos;, password=&quot;123456&quot;, database=&apos;test1&apos;, port=3306, charset=&apos;utf8mb4&apos;)</span><br><span class="line">try:</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(&apos;insert into t_generate_id () values ()&apos;)</span><br><span class="line">    last_id = cursor.lastrowid</span><br><span class="line">    conn.commit()</span><br><span class="line">except Exception as e:</span><br><span class="line">    conn.rollback()</span><br><span class="line">finally:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure></p>
<p>注意：    </p>
<ol>
<li>插入记录时，不能自己去指定自增列的值，这样才能使用<code>cursor.lastrowid</code>获取插入数据的自增长列的值，否则结果都是0。</li>
<li>记得commit。否则<code>auto_increment</code>的值是获取到了，但是记录并没有写入数据库。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/08/CentOS7下修改Docker工作目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/08/CentOS7下修改Docker工作目录/" itemprop="url">CentOS7下修改Docker工作目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T14:48:21+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>服务器系统盘空间不是很充足，而Docker的环境体积又比较大，有必要把其工作目录放到空间较大的数据盘。</p>
</blockquote>
<p>Docker安装时如果不指定工作目录，一般默认工作目录是<code>/var/lib/docker</code>。<br>我们可以先查看一下docker运行的工作目录：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker info |grep &quot;Docker Root Dir&quot;</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br></pre></td></tr></table></figure></p>
<p>现在我们需要把工作目录改为<code>/data/docker</code>，网上提到有2种方法：</p>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>新建或者编辑<code>/etc/docker/daemon.json</code>：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/data/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后重启Docker：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>编辑文件<code>/usr/lib/systemd/system/docker.service</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --data-root=/data/docker</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2……</span><br></pre></td></tr></table></figure></p>
<p>重启docker:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/解决MongoDB游标超时的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/解决MongoDB游标超时的问题/" itemprop="url">解决MongoDB游标超时的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T11:31:16+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>当我们用Python从MongoDB中查数据时，经常遇到游标。实际上不止是MongoDB，我们用MySQL之类，同样也经常用到游标，用游标会出现什么问题，又是如何解决呢？</p>
</blockquote>
<h1 id="使用游标可能遇到的问题"><a href="#使用游标可能遇到的问题" class="headerlink" title="使用游标可能遇到的问题"></a>使用游标可能遇到的问题</h1><p>我们可能这样写代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line">from urllib.parse import quote_plus</span><br><span class="line"></span><br><span class="line">uri = &quot;mongodb://%s:%s@%s&quot; % (quote_plus(&apos;mongo-admin&apos;), quote_plus(&apos;tisson!1&apos;), &quot;aliyun:37071&quot;)</span><br><span class="line"></span><br><span class="line">client = MongoClient(uri)</span><br><span class="line"># crawler为“库名”，collection_1为Collection名，也可以理解为“表名”</span><br><span class="line">my_set = client.crawler.collection_1</span><br><span class="line">for item in my_set.find():</span><br><span class="line">    # 处理找到的数据</span><br><span class="line">    process_data(item)</span><br></pre></td></tr></table></figure></p>
<p>短短几行代码，读取MongoDB中某个表的每一行数据，然后由<code>process _data</code>方法做处理，处理完后再读取下一行，逻辑清晰而简单，能有什么问题？<code>process _data(item)</code>不报错，这一段代码就完美无缺。<br>然而事实并非这样，代码可能会在<code>for item in my_set.find():</code>这一行中报错，而且不是一开始就报错，有可能跑了循环中的若干次后才报错，怎么回事呢？<br>原来<code>my_set.find()</code>返回的并不是数据库里的数据，而是一个游标（Cursor）对象，只有当你使用for循环开始迭代它的时候，游标才会真正去数据库。但是，如果每一次循环都连接数据库，那么网络连接会浪费大量的时间。所以pymongo会一次性获取100行，<code>my_set.find()</code>循环第一次时，它会连上MongoDB，读取一百条数据，缓存到内存中。于是循环的第2-100次，数据都是直接从内存中获取，不会连接数据库。当循环进行到第101次时，再一次连接数据库，获取第101-200行的内容。<br>这个逻辑非常有效的降低了网络I/O耗时，但是，MongoDB默认游标的超时时间是10分钟。10分钟之内，必需再次连接MongoDB读取内容刷新游标时间，否则，就会导致游标超时报错：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pymongo.errors.CursorNotFound: cursor id 40929404302 not found</span><br></pre></td></tr></table></figure></p>
<p>也就是说，如果<code>process _data(item)</code>执行100次的时间超过10分钟，即使该方法没报错，那么等它跑完，需要重新连接数据库获取下100条记录的时候，由于游标超时，就会报错。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>为了解决以上问题，我们有4种办法</p>
<h2 id="修改MongoDB配置"><a href="#修改MongoDB配置" class="headerlink" title="修改MongoDB配置"></a>修改MongoDB配置</h2><p>修改MongoDB的配置，延长游标超时时间，并重启MongoDB。假如是生产环境的数据库，按理说不能随便重启，因此这个做法要慎重。</p>
<h2 id="一次性读取所有数据"><a href="#一次性读取所有数据" class="headerlink" title="一次性读取所有数据"></a>一次性读取所有数据</h2><p>一次性把数据全部读取下来，再做处理：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs_list = [r for r in my_set.find()]</span><br><span class="line">for r in rs_list:</span><br><span class="line">    process_data(r)</span><br></pre></td></tr></table></figure></p>
<p>这种方案的弊端也很明显，如果数据量非常大，你不一定能全部放到内存里面。即使能够全部放到内存中，但是列表推导式遍历了所有数据，紧接着for循环又遍历一次，浪费了时间。不过，暂时在实际情况中，我较常使用这种处理办法，因为处理简单。</p>
<h2 id="减少游标每次返回数据量"><a href="#减少游标每次返回数据量" class="headerlink" title="减少游标每次返回数据量"></a>减少游标每次返回数据量</h2><p>如果处理100条数据会超过10分钟的超时时间，那么我们减少游标每次返回的数据量，例如50条：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in my_set.find().batch_size(50):</span><br><span class="line">    process_data(item)</span><br></pre></td></tr></table></figure></p>
<p>但这种方案会增加数据库的连接次数，从而增加I/O耗时。</p>
<h2 id="让Pymongo的游标永不超时"><a href="#让Pymongo的游标永不超时" class="headerlink" title="让Pymongo的游标永不超时"></a>让Pymongo的游标永不超时</h2><p>通过设定参数<code>no_cursor_timeout=True</code>，让游标永不超时，游标最后必须手动关闭：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cursor = my_set.find(no_cursor_timeout=True)</span><br><span class="line">for row in cursor:</span><br><span class="line">    process_data(row)</span><br><span class="line"># 一定要手动关闭游标</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure></p>
<p>然而这个操作非常危险，因为如果你的Python程序因为某种原因意外停止了，这个游标就再也无法关闭了！除非重启MongoDB，否则这些游标会一直留在MongoDB上，占用资源。<br>因此，我们需要把这个做法稍作改良</p>
<h3 id="使用try、catch、finally"><a href="#使用try、catch、finally" class="headerlink" title="使用try、catch、finally"></a>使用try、catch、finally</h3><p>最容易想到的做法，即使抛出异常，finally部分的代码依然会执行<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cursor = my_set.find(no_cursor_timeout=True)</span><br><span class="line">try:</span><br><span class="line">    for row in cursor:</span><br><span class="line">        process_data(row)</span><br><span class="line">except Exception:</span><br><span class="line">    # 处理异常</span><br><span class="line">    handle_exception()</span><br><span class="line">finally:</span><br><span class="line">    # 一定要手动关闭游标</span><br><span class="line">    cursor.close()</span><br></pre></td></tr></table></figure></p>
<h3 id="使用上下文管理器"><a href="#使用上下文管理器" class="headerlink" title="使用上下文管理器"></a>使用上下文管理器</h3><p>try/catch比较难看，Python还提供了上下文管理器，例如文件的读取与写入我们就可以用上下文管理器：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with my_set.find(no_cursor_timeout=True) as cursor:</span><br><span class="line">    for row in cursor:</span><br><span class="line">        process_data(row)</span><br></pre></td></tr></table></figure></p>
<p>只要程序退出了with的缩进，游标自动就会关闭。如果程序中途报错，游标也会关闭。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/为基于Debian的Docker镜像更换镜像源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/为基于Debian的Docker镜像更换镜像源/" itemprop="url">为基于Debian的Docker镜像更换镜像源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-07T20:32:51+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>docker 官方的镜像大多基于debian，但是官方源apt-get update经常更新失败，要不就是速度很慢，我们需要添加/更换成中国的源</p>
</blockquote>
<h1 id="创建镜像时添加-更换"><a href="#创建镜像时添加-更换" class="headerlink" title="创建镜像时添加/更换"></a>创建镜像时添加/更换</h1><p>可以选择阿里云的源或者网易的源</p>
<h2 id="阿里云的源"><a href="#阿里云的源" class="headerlink" title="阿里云的源"></a>阿里云的源</h2><p>在Dockerfile中添加如下指令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; \</span><br><span class="line">	echo &quot;deb http://mirrors.aliyun.com/debian wheezy main contrib non-free&quot; &gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb-src http://mirrors.aliyun.com/debian wheezy main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb http://mirrors.aliyun.com/debian wheezy-updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb-src http://mirrors.aliyun.com/debian wheezy-updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb http://mirrors.aliyun.com/debian-security wheezy/updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb-src http://mirrors.aliyun.com/debian-security wheezy/updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>
<h2 id="网易的源"><a href="#网易的源" class="headerlink" title="网易的源"></a>网易的源</h2><p>在Dockerfile中添加如下指令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; \</span><br><span class="line">	echo &quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">	echo &quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>
<h1 id="容器运行后添加-更换"><a href="#容器运行后添加-更换" class="headerlink" title="容器运行后添加/更换"></a>容器运行后添加/更换</h1><p>首先进入容器：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it 容器名 bash</span><br></pre></td></tr></table></figure></p>
<p>然后备份一下/etc/apt/sources.list：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure></p>
<p>然后往/etc/apt/sources.list添加源（和上边“创建镜像时添加”一样，这里我们以使用阿里云为例）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb http://mirrors.aliyun.com/debian wheezy main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br><span class="line">$ echo &quot;deb-src http://mirrors.aliyun.com/debian wheezy main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br><span class="line">$ echo &quot;deb http://mirrors.aliyun.com/debian wheezy-updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br><span class="line">$ echo &quot;deb-src http://mirrors.aliyun.com/debian wheezy-updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br><span class="line">$ echo &quot;deb http://mirrors.aliyun.com/debian-security wheezy/updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br><span class="line">$ echo &quot;deb-src http://mirrors.aliyun.com/debian-security wheezy/updates main contrib non-free&quot; &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>
<p>接下来执行以下命令，就完成阿里云镜像源了<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update</span><br></pre></td></tr></table></figure></p>
<p>由于是在容器内变更的，因此容器删除后就没了，我们可以考虑把这个更换了镜像源的容器变为一个新的Docker镜像，这样就不用每次创建容器后再去更改Debian镜像源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/02/Docker容器转镜像/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/02/Docker容器转镜像/" itemprop="url">Docker容器转镜像</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-02T00:46:47+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>有些时候我们在Docker容器内装了某些东西，那要维持那套环境只能一直使用该容器了，如果遇到需要更改环境配置（例如端口映射变更，数据盘映射变更等），需要删掉容器，用镜像文件重新创建容器，又希望能继续使用之前在容器内安装的东西，怎么办呢？</p>
</blockquote>
<p>答案就是把容器内容保存下来，转换成镜像。以后就用这个镜像创建容器。<br>我们将使用docker commit命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure></p>
<p>OPTIONS说明：<br>-a :提交的镜像作者<br>-c :使用Dockerfile指令来创建镜像；<br>-m :提交时的说明文字；<br>-p :在commit时，将容器暂停。 </p>
<p>例如，我们把ID是bc52b8d6886c的容器转化成名为new-image，tag为2.0的镜像：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit bc52b8d6886c new-image:2.0</span><br></pre></td></tr></table></figure></p>
<p>以后我们就可以在这个新的镜像上建立容器进行各种操作，之前的容器可以不要了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/02/Elasticsearch常用查询过滤语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/02/Elasticsearch常用查询过滤语句/" itemprop="url">Elasticsearch常用查询过滤语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-02T00:45:59+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Elasticsearch的语法上手有些难度，会出现很多嵌套，一开始还真被它吓着了</p>
</blockquote>
<h1 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h1><p>在查询上下文中，查询会回答这个问题——“这个文档匹不匹配这个查询，它的相关度高么？”<br>如何验证匹配很好理解，如何计算相关度呢？ES中索引的数据都会存储一个“_score”分值，分值越高就代表越匹配。另外关于某个搜索的分值计算还是很复杂的，因此也需要一定的时间。<br>查询上下文 是在 使用query进行查询时的执行环境，比如使用search的时候。<br>一些query的场景：</p>
<ul>
<li>与full text search的匹配度最高</li>
<li>包含run单词，如果包含这些单词：runs、running、jog、sprint，也被视为包含run单词</li>
<li>包含quick、brown、fox。这些词越接近，这份文档的相关性就越高</li>
</ul>
<h2 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h2><p>可以查询到所有文档，是没有查询条件下的默认语句。此查询常用于合并过滤条件。 比如说你需要检索所有的邮箱,所有的文档相关性都是相同的，所以得到的_score为1<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h2><p>match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符，以下语句，tweet包含“About”、“Search”，或者同时包含“About”和“Search”的记录都会被返回：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;tweet&quot;: &quot;About Search&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果用match下指定了一个确切值，在遇到数字，日期，布尔值或者not_analyzed 的字符串时，它将为你搜索你给定的值：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;match&quot;: &#123; &quot;age&quot;:    26           &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;date&quot;:   &quot;2014-09-01&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;public&quot;: true         &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;tag&quot;:    &quot;full_text&quot;  &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>提示： 做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。match查询只能就指定某个确切字段某个确切的值进行搜索，而你要做的就是为它指定正确的字段名以避免语法错误。</p>
<h2 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h2><p>multi_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个，例如我想查询title字段和body字段都含有“text”的记录：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;multi_match&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:    &quot;text&quot;,</span><br><span class="line">            &quot;fields&quot;:   [ &quot;title&quot;, &quot;body&quot; ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h2><p>bool 查询与 bool 过滤相似，用于合并多个查询子句。不同的是，bool 过滤可以直接给出是否匹配成功， 而bool 查询要计算每一个查询子句的_score （相关性分值）。</p>
<ul>
<li>must：查询指定文档一定要被包含。</li>
<li>must_not：查询指定文档一定不要被包含。</li>
<li>should：查询指定文档，有则可以为文档相关性加分。</li>
</ul>
<p>以下查询将会找到 title 字段中包含 “how to make millions”，并且 “tag” 字段没有被标为 spam。 如果有标识为 “starred” 或者发布日期为2014年之后，那么这些匹配的文档将比同类网站等级高：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123; </span><br><span class="line">                &quot;match&quot;: &#123; </span><br><span class="line">                    &quot;title&quot;: &quot;how to make millions&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;must_not&quot;:&#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;tag&quot;:   &quot;spam&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;should&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;match&quot;:&#123;</span><br><span class="line">                        &quot;tag&quot;: &quot;starred&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;range&quot;:&#123;</span><br><span class="line">                        &quot;date&quot;: &#123; &quot;gte&quot;: &quot;2014-01-01&quot; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提示： 如果bool 查询下没有must子句，那至少应该有一个should子句。但是 如果有must子句，那么没有should子句也可以进行查询。</p>
<h2 id="wildcards-查询"><a href="#wildcards-查询" class="headerlink" title="wildcards 查询"></a>wildcards 查询</h2><p>使用标准的shell通配符查询<br>以下查询能够匹配包含W1F 7HW和W2F 8HW的文档：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;wildcard&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W?F*HW&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又比如下面查询 hostname 匹配下面shell通配符的：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;wildcard&quot;: &#123;</span><br><span class="line">            &quot;hostname&quot;: &quot;wxopen*&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h2><p>假设只想匹配以W开头，紧跟着数字的邮政编码。使用regexp查询能够让你写下更复杂的模式：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&apos;:&#123;</span><br><span class="line">        &quot;regexp&quot;:&#123;</span><br><span class="line">	    &quot;postcode&quot;: &quot;W[0-9].+&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面例子是所有以 wxopen 开头的正则<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&apos;:&#123;</span><br><span class="line">        &quot;regexp&quot;:&#123;</span><br><span class="line">	    &quot;postcode&quot;: &quot;wxopen.*&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="prefix查询"><a href="#prefix查询" class="headerlink" title="prefix查询"></a>prefix查询</h2><p>以什么字符开头的，可以更简单地用 prefix，如下面的例子：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&apos;:&#123;</span><br><span class="line">        &quot;prefix&quot;:&#123;</span><br><span class="line">	    &quot;postcode&quot;: &quot;wxopen&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h2><p>当你需要寻找邻近的几个单词时，你会使用match_phrase查询：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&apos;:&#123;</span><br><span class="line">        &quot;match_phrase&quot;:&#123;</span><br><span class="line">	    &quot;title&quot;: &quot;quick brown fox&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和match查询类似，match_phrase查询首先解析查询字符串来产生一个词条列表。然后会搜索所有的词条，但只保留含有了所有搜索词条的文档，并且词条的位置要邻接。一个针对短语quick fox的查询不会匹配我们的任何文档，因为没有文档含有邻接在一起的quick和box词条。<br>match_phrase查询也可以写成类型为phrase的match查询：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&apos;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">	    &quot;title&quot;: &#123;</span><br><span class="line">                &quot;query&quot;:&quot;quick brown fox&quot;,</span><br><span class="line">		&quot;type&quot;:&quot;phrase&quot;</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Filter-DSL"><a href="#Filter-DSL" class="headerlink" title="Filter DSL"></a>Filter DSL</h1><p>在过滤器上下文中，查询会回答这个问题——“这个文档匹不匹配？”<br>答案很简单，是或者不是。它不会去计算任何分值，也不会关心返回的排序问题，因此效率会高一点。<br>过滤上下文 是在使用filter参数时候的执行环境，比如在bool查询中使用Must_not或者filter。<br>另外，经常使用过滤器，ES会自动的缓存过滤器的内容，这对于查询来说，会提高很多性能。<br>一些过滤的情景：</p>
<ul>
<li>创建日期是否在2013-2014年间？</li>
<li>status字段是否为published？</li>
<li>lat字段是否在某个坐标的10公里范围内？</li>
</ul>
<h2 id="term-过滤"><a href="#term-过滤" class="headerlink" title="term 过滤"></a>term 过滤</h2><p>尽管看上去像个“查询”，但是如果结果不完全符合条件它是不会返回的。<br>term主要用于精确匹配哪些值，比如数字，日期，布尔值或 string 的字符串(未经分析的文本数据类型)，我的理解是，它不会对term的条件再进行分词：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">	&quot;term&quot;:&#123;</span><br><span class="line">	    &quot;prj_name&quot;:&quot;汕尾土建&quot;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上语句，prj name为“汕尾XXXXX土建”的记录并不会被返回。</p>
<h2 id="terms-过滤"><a href="#terms-过滤" class="headerlink" title="terms 过滤"></a>terms 过滤</h2><p>terms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配（就是说，只要满足其中之一的条件）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">	&quot;terms&quot;:&#123;</span><br><span class="line">	    &quot;prj_name&quot;:[&quot;汕尾&quot;,&quot;土建&quot;]</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上语句，可以返回prj name为“汕尾XXXXX”和“江门XX土建”的记录。</p>
<h2 id="range过滤"><a href="#range过滤" class="headerlink" title="range过滤"></a>range过滤</h2><p>range过滤允许我们按照指定范围查找一批数据，例如寻找“年龄为20岁到30岁之间的记录”：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">	&quot;range&quot;:&#123;</span><br><span class="line">	    &quot;age&quot;:&#123;</span><br><span class="line">		&quot;gte&quot;:20,</span><br><span class="line">		&quot;lte&quot;:30</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="exists-和-missing-过滤"><a href="#exists-和-missing-过滤" class="headerlink" title="exists 和 missing 过滤"></a>exists 和 missing 过滤</h2><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS NOT NUL和IS NULL条件。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">	&quot;exists&quot;:   &#123;</span><br><span class="line">	    &quot;field&quot;:true</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bool过滤"><a href="#bool过滤" class="headerlink" title="bool过滤"></a>bool过滤</h2><p>bool下可以跟“filter”。官网的解释是这样的：“The clause (query) must appear in matching documents. However unlike must the score of the query will be ignored. Filter clauses are excuted in filter context, meaning that scoring is ignored and clauses are considered for caching”。按照我的理解，基本等同于bool查询的must吧，只不过省略了评分（全部为0），快一些，可以用到缓存。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;filter&quot;:&#123; </span><br><span class="line">                &quot;match&quot;: &#123; </span><br><span class="line">                    &quot;title&quot;: &quot;how to make millions&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/解决Docker容器与主机时间不同步问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/01/解决Docker容器与主机时间不同步问题/" itemprop="url">解决Docker容器与主机时间不同步问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T17:05:03+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在Docker容器运行后，可能会发现容器时间与宿主机时间不一致，一般会差8个小时。这样会造成在容器中运行的web程序打出的日志时间与实际时间不一致，如果web程序中有定时任务也会造成影响等，需要对宿主机和容器进行时间同步。</p>
</blockquote>
<p>宿主机时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9aiqq9qrjr7ovag8caZ ~] date</span><br><span class="line">2019年 8月28日 星期三 11时31分03秒 CST</span><br></pre></td></tr></table></figure></p>
<p>容器时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ac1c371435ac:/# date</span><br><span class="line">Wed Aug 28 03:31:03 UTC 2019</span><br></pre></td></tr></table></figure></p>
<p>可以看到宿主机和容器时间相查8个小时，宿主机采用CST时区，CST是指China Shanghai Time，东八区时间；容器采用UTC时区，UTC应该是指Coordinated Universal Time，标准时间。</p>
<p><strong>统一两者的办法是共享主机的时间与时区</strong><br>网上有说共享主机localtime的，有说设置时区的，我发现，只做其中一种方法的话，有些能成功，有些不成功，例如进入容器内看到时间是东八区的时间了，但是打印出来的日志还是UTC。如果localtime与timezone一起设置的话貌似能保证成功：   </p>
<ol>
<li><p>我们先看看宿主机的时区，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/timezone</span><br><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候宿主机没有，我们要创建一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/timezone</span><br><span class="line">cat: /etc/timezone: No such file or directory</span><br><span class="line"># 如果要创建/etc/timezone，需要root账号，用一般账号sudo也不行</span><br><span class="line">$ echo &quot;Asia/Shanghai&quot; &gt; /home/tisson/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享主机的localtime与timezone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果宿主机有/etc/timezone</span><br><span class="line">$ docker run -d --name zk -p 2181:2181 -p 2888:2888 -p 3888:3888 -v /etc/localtime:/etc/localtime:ro -v /etc/timezone:/etc/timezone:ro wurstmeister/zookeeper:3.4.6</span><br><span class="line"></span><br><span class="line"># 如果宿主机没有/etc/timezone，我们就用自己创建的timezone</span><br><span class="line">$ docker run -d --name zk -p 2181:2181 -p 2888:2888 -p 3888:3888 -v /etc/localtime:/etc/localtime:ro -v /home/tisson/timezone:/etc/timezone:ro wurstmeister/zookeeper:3.4.6</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：某些容器日志信息用的是自带JVM的时区，如果要改变时区，可能需要具体分析通过设置什么参数改变这个时区。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/Docker容器间通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/Docker容器间通信/" itemprop="url">Docker容器间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T14:23:40+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>每个容器有一个独立的ip，而且跟宿主机的ip是两套东西，如何实现容器间/容器与宿主机互相通信？</p>
</blockquote>
<p>例如我部署了一个Java WEB容器，一个数据库容器，Java WEB容器需要访问数据库容器。在使用Docker之前，要做到这件事挺容易，Java WEB容器直接写数据库地址即可，假如Java WEB服务与数据库在同一个服务器，可以直接写127.0.0.1 或者localhost。但是，使用Docker容器之后，容器内部有独立于主机的一套IP，即使Java WEB与数据库容器都在同一个主机上，在JAVA WEB容器内访问127.0.0.1是找不到数据库容器的。怎么办？网上能搜到一堆答案，不过由于对网络这块我不是很熟悉，有很多从“网桥”这个方向的解决方案我是完全看不懂，我能看懂并实际应用的只有下边两种：</p>
<h1 id="link方式"><a href="#link方式" class="headerlink" title="link方式"></a>link方式</h1><p>我们启动Docker容器的时候可以指定容器的名字，例如我启动一个MySQL的容器，指定其名字为mysql57<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name mysql57 MYSQL_ROOT_PASSWORD=123456 -p 3308:3306 -d docker.io/mysql:5.7.23 --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci</span><br></pre></td></tr></table></figure></p>
<p>现在，我们启动Java WEB容器，并允许其访问到mysql57这个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  --link mysql57:mysql57 -p 8084:8084 -d tisson/dict-web:latest</span><br></pre></td></tr></table></figure></p>
<p>容器内配置的数据源地址为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用mysql57这个地址可以访问到mysql57容器，注意mysql57容器内部使用的是3306端口，但是映射到主机是3308端口，我们使用link的方式访问，应该使用该容器内部的端口：3306</span><br><span class="line">spring.datasource.url=jdbc:mysql://mysql57:3306/dict?......</span><br></pre></td></tr></table></figure></p>
<h1 id="add-host方式"><a href="#add-host方式" class="headerlink" title="add-host方式"></a>add-host方式</h1><p>link方式用了一阵，很快我就发现了一些问题：</p>
<ol>
<li>容器必须按次序启动，例如我启动Java WEB容器的时候，添加了使用mysql57的link，那么在mysql57容器成功启动之前，我启动Java WEB容器会报错。再考虑极端一些的情况，假如两个容器需要相互访问，要怎么办呢？</li>
<li>曾经遇到：A容器需要link到B容器，而B容器因为某些原因需要删除，然后重新打包镜像，运行容器，名字也是B。然后A总是说连不上B了，只能把A也删掉，重新建一个A容器</li>
<li>如果需要相互通信的容器不在同一台主机上，要怎么做</li>
</ol>
<p>最无脑的办法是不用“link”，直接写死外网IP。因为容器内也是可以访问到主机的外网IP。但是，如果我们要做服务迁移呢？每迁移一次就改一大堆地址？挺麻烦的样子。然后我又想到了使用hostname，直接让容器内的hosts文件挂载到主机的hosts文件，但是docker启动的时候某些参数也会修改容器内部的hosts，我不知道是否会影响到主机的hosts。如何为容器添加hostname又不影响主机hosts呢？还真有方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用--add-host参数，也不用管哪个容器先启动了，也可以跨主机访问</span><br><span class="line">$ docker run  --add-host ctyun1:10.10.0.234 --add-host ctyun2:10.10.0.79 --add-host ctyun3:10.10.0.116  -p 8084:8084 -d tisson/dict-web:latest</span><br></pre></td></tr></table></figure></p>
<h1 id="留意防火墙"><a href="#留意防火墙" class="headerlink" title="留意防火墙"></a>留意防火墙</h1><p>最近服务器迁移时遇到的问题，新部署的docker容器，无法访问宿主机的ip，表现为：</p>
<ol>
<li>容器内部可以ping得通宿主机的ip</li>
<li>容器内部curl宿主机的ip缺报错：No route to host</li>
<li>容器内可以访问同一主机上的其他容器</li>
</ol>
<p>经查，居然是防火墙的问题（系统是CentOS 7.5），比方说，我有个java web的docker容器服务，要访问主机上的mysql数据库，端口号为3306，那么需要在防火墙开放开放指定端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">success</span><br><span class="line">$ sudo firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/Docker查看容器日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/Docker查看容器日志/" itemprop="url">Docker查看容器日志</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T14:23:27+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>（容器）控制台的日志</p>
</blockquote>
<h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>需要知道该容器的ID（不用全部输入，输前边几位就可以了）或名字：例如<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">b2c2d420d3f1        docker.io/mysql:5.7.23   &quot;docker-entrypoint...&quot;   2 days ago          Up 2 days           33060/tcp, 0.0.0.0:3308-&gt;3306/tcp                mysql57</span><br><span class="line"># 以下两条命令均可</span><br><span class="line">$ docker logs b2c </span><br><span class="line">$ docker logs mysql57</span><br></pre></td></tr></table></figure></p>
<h2 id="查看特定时间的日志"><a href="#查看特定时间的日志" class="headerlink" title="查看特定时间的日志"></a>查看特定时间的日志</h2><p>日志一多是显示不完的，我们可以指定只显示特定时间内的日志。<br>例如我想看最近30分钟的日志<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --since 30m CONTAINER_ID</span><br></pre></td></tr></table></figure></p>
<p>查看某时间之后的日志：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; CONTAINER_ID</span><br></pre></td></tr></table></figure></p>
<p>查看某时间段日志：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID</span><br></pre></td></tr></table></figure></p>
<h2 id="查看最近的日志"><a href="#查看最近的日志" class="headerlink" title="查看最近的日志"></a>查看最近的日志</h2><p>例如，我要看日志的最后100行<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --tail=100 CONTAINER_ID</span><br></pre></td></tr></table></figure></p>
<p>可以和日期一同使用<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -f ：跟踪实时日志；-t：显示时间戳</span><br><span class="line">$ docker logs -f -t --since=&quot;2018-12-07&quot; --tail=100 CONTAINER_ID</span><br></pre></td></tr></table></figure></p>
<h1 id="【重要】限制日志大小"><a href="#【重要】限制日志大小" class="headerlink" title="【重要】限制日志大小"></a>【重要】限制日志大小</h1><p>日志虽然写在容器内，但实际上也是用到宿主机的存储空间，有些服务会写很多日志，如果不加以限制，日志不断膨胀甚至有可能沾满整个存储空间。   </p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改/etc/docker/daemon.json，没有就新建一个<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># max-size=500m，意味着一个容器日志大小上限是500M</span><br><span class="line"># max-file=3，意味着一个容器有三个日志，分别是id+.json、id+1.json、id+2.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">&quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;3&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重启docker守护线程"><a href="#重启docker守护线程" class="headerlink" title="重启docker守护线程"></a>重启docker守护线程</h2><p>命令如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：设置的日志大小规则，只对新建的容器有效</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/Docker镜像导出导入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sea Monster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/Docker镜像导出导入/" itemprop="url">Docker镜像导出导入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T14:21:37+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这就是我们使用Docker的一大理由。先下载一个基础的镜像，然后在此基础上安装我们需要的各种软件、环境什么的东西，形成一个新的镜像。然后这个镜像可以直接用在其他机器，节省大量配环境的时间。</p>
</blockquote>
<h1 id="镜像文件导出"><a href="#镜像文件导出" class="headerlink" title="镜像文件导出"></a>镜像文件导出</h1><p>先查看我们要导出的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tisson/jdk8_rar           latest              2d754ec2021c        8 days ago          511MB</span><br><span class="line">openjdk                   8u212               4a0a42e87cf3        12 days ago         488MB</span><br><span class="line">mongo                     latest              0fb47b43df19        12 days ago         411MB</span><br><span class="line">tisson/jdk8u181chrome     2.0                 10458e5525f5        3 months ago        1.04GB</span><br></pre></td></tr></table></figure></p>
<p>假设我们要导出“tisson/jdk8u181chrome”这个镜像，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker save -o jdk8u181chrome.tar tisson/jdk8u181chrome:2.0</span><br></pre></td></tr></table></figure></p>
<p>这样就会在当前目录生成jdk8u181chrome.tar文件，然后我们下载此文件，或将此文件上传到特定服务器。</p>
<h1 id="镜像文件导入"><a href="#镜像文件导入" class="headerlink" title="镜像文件导入"></a>镜像文件导入</h1><p>现在我们要在另一台机器上导入tisson/jdk8u181chrome镜像，首先把jdk8u181chrome.tar文件放到当前目录，然后运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker load -i jdk8u181chrome.tar</span><br></pre></td></tr></table></figure></p>
<p>即可导入此镜像，而且此镜像的名字和tag将和导出时保持一致，当然，某些情况下，可能我们需要为这个镜像改下名字</p>
<h2 id="更改镜像名称与标记"><a href="#更改镜像名称与标记" class="headerlink" title="更改镜像名称与标记"></a>更改镜像名称与标记</h2><p>例如我们有镜像tisson/jdk8u181chrome，其标记为2.0，我们准备改为java8chrome，标记改为v1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag tisson/jdk8u181chrome:2.0 java8chrome:v1</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sea Monster</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sea Monster</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
